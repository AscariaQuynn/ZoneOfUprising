

- brzdeni bocniho pohybu ma nastarosti vylucne engines control
- otaceni za cilem ma nastarosti engines control, ktera vraci dot product z rotace (getRequiredRotationDot)
- rotation pid nema nastarosti brzdeni rotace, to se bude vypocitavat uvnitr engines control

engines control bude mit metody getLinearVelocityDot a getRotationDot, ktere bude nepretrzite nastavovat
v zavislosti na tom, jak moc je smer lodi mimo od pozadovaneho smeru (lod driftuje),
nebo je jeji cumak mimo od pozadovane rotace (lod kouka jinam nez chceme)

- pokud bude vypnuty rotation control nebo movement control, vyse uvedene metody budou vracet
  vzdy 1f, protoze budeme predpokladat, ze se lod vzdy kouka ci leti spravne


- arrival pouziva engines control na ruseni bocniho pohybu a enginescontrol's
  rotacni dot na urceni jestli zazehnout zadni trysky
  bude nastavovat motorum required rotation a zazehavat trysky motoru

- aimcontrol pouziva engines control na zamireni pozadovane rotace lodi
  tzn bude jen nastavovat required rotation motorum

- nejak vymyslet, aby bylo mozno zadavat motorum i tah, aby nebyl vzdy 100%

- pri zmacknuti dvou sipek do opacnych stran musi byt vysledek 0 a ne +(-)1

- svet se bude zacitat stejne jako entita, pomoci requestWorld (sjednotit chovani s entitou),
  po obdrzeni server profile si server zazada o svet a bude mu vracen selected svet
- v severovy konzoly udelat prikaz na vypsani dostupnych svetu a prikaz na nacteni sveta
- nejdriv asi reloadovani sveta kopne vsechny entity, ale mohlo by jim to zobrazit loading
  a nacit rovnou jiny svet taky

ok - kdyz mam malo hp, pustit sirenu, jen na svy vlastni lodi

- linear force bude poustet jen predni a zadni trysky, bocni jen angular force jak je to ted
- - zajistit aby po pusteni klaves po vypnuti perma trysek se nespustily tmp trysky
- - pri ovladani rotace mysi nebo sipkama, udelat taky u hrace perma rotacni trysky
- - treba pri vypnuti perma trysek bude 0.5sec timeout ingnorovani tmp trysek

- engines control by mela mit metody, ktere vrati maximalni mozny thrust a torque (nejak
  vykalkulovat z pid controlleru, treba vectorx cross vectory, pravy uhel, aby to udelalo max error,
  nebo jen rict pid controlleru at vrati max error)
  a podle toho bude thrusters control adjustovat velocity trysek
  a treba i pocet particles od 50% (0) - 100% (max thrust)

- projektilu se predava collidables, projektilove collidables by melo byt schopno vyradit
  svou entitu z detekce kolizi. jelikoz ale nemuzu pole zduplikovat, protoze by tam zustaly
  znicene lode, tak pri prochazeni collidables a aplikoavni collidewith, musim pridat podminku
  co odignoruje sama sebe

- collidables zvazit udelat jako pair entityprofile-entity a vubec vytvorit a zavest
  entityprofile-entity pairy navazany na entity name, pak to pujde lehce narvat do systemu
  a melo by z toho jit i urcovat, jestli je hrac nalodovany ale jeho entita je znicena,
  cili respawn

- entitybuilder staci jeden v entity managerovi
- class entity co bude obsahovat spatial a entityprofile, zvazit jak udelat entityupdater
- class entity bude umet respawnovat

- restart world ve world managerovi, zachova entity s entityprofile ale uz ne spatial

- zbavit se getrotationcolumn a nahradit to za q.mult(vector_z...)

- entity profile a item bude moct brat vlastnosti itemu stylem
  entityProfile.getColorRGBA(name, default) item.getFloat(name, default)
